#!/usr/bin/env ruby
require 'rubygems' # wayne seguine told me this is ok in application code
require 'pathname'
require 'shellwords'

module Hipe; end

# allow this to be subsumed into a multiplexing app without reliance on rubygems to load tinyscript
here = File.dirname(__FILE__)
require here + '/hipe-tinyscript/core' unless Hipe.const_defined? :Tinyscript
require here + '/hipe-tinyscript/support' unless Hipe::Tinyscript.const_defined? :Support
require here + '/support'

# require 'ruby-debug'; puts Hipe::Tinyscript::Colorize.colorize("foo", :blink, :bright, :red);

module Hipe::FileMetrics
  VERSION = '0.3.0'

  module PathTools
    def escape_path path
      (path =~ / |\$|'/) ? Shellwords.shellescape(path) : path
    end
  end

  class FindCommand
    include PathTools
    def initialize
      @extra = ''
      yield self
      fail('need at least one search path') unless @paths && @paths.any?
    end
    attr_accessor :extra
    ivars = [:paths, :skip_dirs, :names]
    attr_writer(*ivars)
    ivars.each do |ivar|
      define_method(ivar) do |*a|
        case a.size ;
        when 0 ; instance_variable_get("@#{ivar}")
        when 1 ; instance_variable_set("@#{ivar}", a.first.kind_of?(Array) ? a.first : [a.first])
        else     instance_variable_set("@#{ivar}", a)
        end
      end
    end
    def render
      cmd = "find " << @paths.map{ |p| escape_path(p) }.join(' ')
      if @skip_dirs && @skip_dirs.any?
        paths = @skip_dirs.map{ |p| escape_path(p) }
        cmd << ' -not \( -type d \( -mindepth 1 -a '
        cmd << paths.map{ |p| " -name '#{p}'" }.join(' -o')
        cmd << " \\) -prune \\)#{@extra}"
      end
      if @names && @names.any?
        paths = @names.map{ |p| escape_path(p) }
        cmd << ' \(' << paths.map{ |p| " -name '#{p}'" }.join(' -o') << ' \)'
      end
      cmd
    end
  end

  class MyCommand < Hipe::Tinyscript::Command
    include PathTools
    def execute
      begin
        execute_no_catch
      rescue SoftError => e
        err e.message
        :errors
      end
    end
    alias_method :orig_on_success, :on_success
    def on_success; end
    def files_find_command paths = nil
      paths ||= param(:paths)
      paths = [paths] unless paths.kind_of?(Array)
      cmd = FindCommand.new do |find|
        find.paths paths
        find.skip_dirs @param[:exclude_dir]
        find.names  @param[:name]
        find.extra = ' -not -type d'
      end
      cmd.render
    end
    def linecount_branch_node_one_level label, files
      # if sort is not available on the system, consider doing it w/ ruby
      return Hipe::DataNode::Branch.new{ |b| b.name = label } if files.size == 0
      read_ok = []
      problems = []
      files.each do |f|
        if File.exist?(f)
          if File.readable?(f)
            read_ok.push(f)
          else
            problems.push [:not_readable, f]
          end
        else
          problems.push [:bad_link, f]
        end
      end
      if problems.any?
        err problems.map{ |reason, file| colorize("#{reason}? ", :red) << file }
      end
      lines = baktix("wc -l #{read_ok * ' '} | sort -g")
      case lines.size
      when 0; raise SoftError.new("not expecting zero lines from wc")
      when 1;
        md = /^(\d+) (.+)$/.match(lines.last) or
          raise SoftError.new("regex fail against wc results: #{lines.last.inspect}")
        wc_total = md[1]
      else
        md = /^ *(\d+) total$/.match(x=lines.pop) or
          raise SoftError.new(%|regex fail against wc results: "#{x}"|)
        wc_total = md[1].to_i
      end
      leaves = lines.map do |wc_line|
        md = wc_line.match(%r{(\d+)\s+(.+)$}) or
          raise SoftError("Failed to match against #{wc_line.inspect}")
        Hipe::DataNode::Leaf.new do |me|
          me.count = md[1].to_i
          me.name = md[2]
        end
      end
      branch = Hipe::DataNode::Branch.new do |b|
        b.name = label
        b.children = leaves
      end
      Hipe::Stats[branch]
    end
  end

  class SoftError < RuntimeError; end

  class App < Hipe::Tinyscript::App
    description <<-desc
      filemetrics - view statistics about distribution of lines of code
      as they are distributed accross a tree of files

      desc
    commands MyCommand
  end

  class Lc < MyCommand
    description <<-desc
      shows the linecount of each file, longest first. Show
      percentages of max for each file.   will go recursively
      into directories.
      desc

    parameter '-n', '--name NAME', :many=>true, :desc=> <<-desc
      e.g. --name='*.rb'.  When present, this limits the
      files analyzed to the ones whose basename matches
      this pattern. It can be specified multiple times to
      add multiple filename patterns, which will broaden
      the search.  You should use single quotes to avoid
      shell expansion.

      When PATH is a file, this option is ignored.

    desc

    parameter '-D', '--exclude-dir DIR', :many=>true, :default=>['.*'], :desc=><<-desc
      folders whose basename match this pattern will not be
      descended into.  It can be specified multiple times
      with multiple patterns to narrow the search.
      If not provided, the default is to skip folders whose
      name starts with a '.' (period).  To include such
      dirs, specify "--exclude-dirs=[]" the first time you
      use this option in the command.  (it has the effect
      of clearing the "blacklist" of directories to skip)

    desc

    parameter '-c', '--command', 'show the generated find command we would have used.'

    parameter '-l', '--list', 'list the resulting files that match the query.'

    parameter '-R', '--no-report', "don't actually run the whole report. (useful only for the 2 above)"

    parameter :paths, :syntaxy_name => 'path', :positional=> 1, :required => false, :default => ['.'],
      :glob => 1, :desc => "the file or directory(s) to search."

    def execute_no_catch
      @param[:name] ||= []
      @param[:exclude_dir].first == '[]' and @param[:exclude_dir].shift
      @param.key?(:command) && out(files_find_command)
      @param.key?(:list) && baktix(files_find_command){ |bt| bt.announce; bt.out{ |line| out line } }
      @param.key?(:no_report) || render_report(baktix(files_find_command){|b| b.announce = false })
      nil
    end

    def render_report filepaths
      branch = linecount_branch_node_one_level('files', filepaths)
      branch.sort_by!{ |node| node.stats.ratio_of_max }
      matrix = branch.children.map do |node|
        [ '%d' % node.stats.count,
          '%5.01f%' % node.stats.percent_of_max,
          node.name
        ]
      end
      tableize(matrix) do |t|
        out "summary of linecounts for #{branch.name}"
        fmt = "%#{t.width(0)}s %#{t.width(1)}s %-#{t.width(2)}s"
        t.rows{ |*row| out fmt % row  }
      end
    end
  end

  class Dirs < MyCommand
    description <<-desc
      experimental report.  all folders one level under <path>,
      for each of them report number of files and total sloc,
      and show them in order of total sloc and percent of max
    desc
    parameter '-n', '--name PATTERN', 'multiple name patterns', :many => true
    parameter '-D', '--exclude-dir DIR', :many => true, :default => ['.*'], :desc =>
      "folders to skip."
    parameter '-c', '--command', 'show the find command'
    parameter '-l', '--list', 'list the matching folders'
    parameter '-R', '--no-report', "don't actually run the report (useful for above options)"
    parameter :path, :required => false, :positional => true, :default => '.'
    def execute_no_catch
      @param[:name] ||= []
      File.exist?(param(:path)) or return err("file does not exist: #{param(:path)}")
      @param[:exclude_dir].first == '[]' and @param[:exclude_dir].shift
      @param.key?(:command) && out(dirs_find_command)
      @param.key?(:list) && out(baktix(dirs_find_command))
      @param.key?(:no_report) || render_report(param(:path), baktix(dirs_find_command))
      nil
    end
    def on_success; end # no 'done.' evar
  private
    def dirs_find_command
      cmd = FindCommand.new do |find|
        find.paths param(:path)
        find.skip_dirs @param[:exclude_dir]
        find.extra = ' -a -maxdepth 1 -type d'
      end
      cmd.render
    end
    def render_report path, folders
      root_list = folders.map do |folder|
        list = baktix(files_find_command(folder))
        linecount_branch_node_one_level(File.basename(folder), list)
      end
      root = Hipe::DataNode::Branch.new do |me|
        me.name = "folders summary"
        me.children = root_list
      end
      Hipe::Stats[root]
      root.sort_by!{ |child| child.stats.count }
      fieldset = Hipe::Tinyscript::Support::Fieldset.new do |fs|
        fs.field(:folder_name)     { |x| x.name }
        fs.field(:total_lines)     { |x| x.stats.count }
        fs.field(:percent_of_max)  { |x| '%5.01f' % x.stats.percent_of_max }
        fs.field(:number_of_files) { |x| x.children.length }
        fs.field(:longest_file)    { |x| x.stats.max }
      end
      matrix = root.children.map{ |node| fieldset.map{ |f| f.render(node) } }
      tableize(matrix) do |t|
        out "summary of folders in #{path}"
        matrix.unshift fieldset.map(&:titleize)
        fmt = fieldset.map{ |f| f.printf_format(t.width(f.index)) }.join(' | ')
        t.rows{ |*row| out(fmt % row) }
      end
    end
  end

  class Ext < MyCommand
    description "just report on the number of files with different extensions,
      ordered by frequency of extension"
    parameter '-D', '--exclude-dir DIR', :many => true, :default => ['.*'], :desc =>
      "folders to skip."
    parameter '--[no-]git', 'be aware of git commit objects,',
                      'glob them in to one category', :default => true
    # parameter '-e', '--each', 'for files with out extensions, show each name'
    parameter '--[no-]singles', 'by default, extensions that occur only once',
                      'are globbed together. Use this flag ',
                      'to include them in the main table.', :default => false

    parameter :path, :positional => true, :required => false,
      :desc => "the folder to look in", :default => '.'

    def execute
      @param[:exclude_dir].shift if @param[:exclude_dir].first == '[]'
      @pats = []
      @pats.push [/^[0-9a-f]{38,40}$/, 'git object'] if @param[:git]
      counts = Hash.new do |h, k|
        h[k] = Hipe::Tinyscript::Support::EpeenStruct[{ :count => 0, :extension => k, :name => k }]
      end
      cmd = FindCommand.new do |find|
        find.paths [param(:path)]
        find.skip_dirs @param[:exclude_dir]
        find.names @param[:name]
        find.extra = ' -not -type d'
      end
      cmd_str = cmd.render
      baktix(cmd.render) do |bt|
        bt.announce = 1 # sure just to see it
        bt.out do |line|
          pn = Pathname.new(line.chomp!)
          ext = pn.extname.to_s
          ext.empty? && (ext = ((pat = @pats.detect{ |p| p[0] =~ pn.basename }) ? pat[1] : pn.basename.to_s))
          counts[ext].count += 1
        end
      end
      root = Hipe::DataNode::Branch.new do |me|
        me.name = "extensions summary"
        me.children = counts.values
      end
      Hipe::Stats[root]
      rows = root.sort_by!{ |node| node.count }
      if ! @param[:one]
        singles = []; multis = []
        rows.each{ |x| (x.count == 1 ? singles : multis).push x }
        singles.sort!{ |x, y| x.extension <=> y.extension }
        rows = multis
      end
      fields = Hipe::Tinyscript::Support::Fieldset.new do |fs|
        fs.field(:extension){ |x| x.extension=='' ? '[none]' : x.extension }
        fs.field(:num_files){ |x| x.count }
        fs.field(:percent_of_max){ |x| '%5.01f' % x.stats.percent_of_max }
      end
      matrix = rows.map{ |r| fields.map{ |f| f.render(r) } }
      tableize(matrix) do |t|
        out "occurences of extensions in #{@param[:path].inspect}:"
        t.rows.unshift fields.map(&:titleize)
        fmt = fields.map{ |f| f.printf_format(t.width(f.index)) }.join(' | ')
        t.rows{ |*row| out fmt % row }
      end
      if singles && singles.any?
        out "occured only once: (#{singles.map(&:extension) * ', '})"
      end
    end
  end
end

Hipe::FileMetrics::App.new.run(ARGV) if File.basename($PROGRAM_NAME) == File.basename(__FILE__)
